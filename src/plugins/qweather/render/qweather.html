{% extends "plugin.html" %}

{% block content %}
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">

<div id="units-container" data-units="{{ units }}"></div>


<div class="weather-dashboard {% if dark_mode %}dark-mode{% endif %} {% if display_style == 'nothing' %}nothing-style{% elif display_style == 'qweather' %}qweather-style{% endif %}">
  {% if plugin_settings.displayRefreshTime == "true" %}
  <div class="last-refresh">{{ labels.last_refresh }}: {{ last_refresh_time }}</div>
  {% endif %}
  <!-- Current Date -->
  <div class="header {% if weather_alerts and weather_alerts|length > 0 %}has-alerts{% endif %}">
    <div class="title">{{ title }}</div>
    <div class="header-bottom-row">
      {% if weather_alerts and weather_alerts|length > 0 %}
      <div class="weather-alerts-inline">
        {% for alert in weather_alerts[:3] %}
          <div class="weather-alert-inline" style="background-color: {{ alert.bg_color }}; color: {{ alert.text_color }};">
            <span class="alert-icon-inline">⚠</span>
            <span class="alert-headline-inline">{{ alert.headline }}</span>
          </div>
        {% endfor %}
      </div>
      {% endif %}
      <div class="current-date">{{ current_date }}</div>
    </div>
  </div>

  <div class="today-container">
    <!-- Current Weather Row -->
    <div class="current-temperature">
      <!-- Icon + Temperature -->
        <img class="current-icon" src="{{current_day_icon}}" alt="Current Weather Icon">
        <div class="current-weather">
          <div class="current-temp">{{ current_temperature }}<span class="temperature-unit">{{temperature_unit}}</span></div>
          <div class="feels-like"><span class="feels-like-label">{{ labels.feels_like }}</span> <span class="feels-like-value">{{ feels_like }}{% if units != "standard" %}°{% endif %}</span></div>
          <div class="min-max">{{ forecast[0].high }}{% if units != "standard" %}°{% endif %} / {{ forecast[0].low }}{% if units != "standard" %}°{% endif %}</div>
        </div>
    </div>

    <!-- Data Points Grid (Sunset, Wind, UV, etc.) -->
    {% if plugin_settings.displayMetrics and  plugin_settings.displayMetrics == "true" %}
    <div class="data-points">
      {% for dp in data_points %}
        <div class="data-point column-container">
          <div class="data-point-img-container">
            <img class="data-point-icon{% if dp.icon and 'air-quality.png' in dp.icon %} aqi-icon{% endif %}"
                 src="{{dp.icon}}" alt="{{ dp.label }}">
          </div>
          <div class="data-point-data">
            <div class="data-point-label">{{ dp.label }}</div>
            <div class="data-point-measurement"{% if dp.aqi_color %} style="color: {{ dp.aqi_color }};"{% endif %}>{{ dp.measurement }}{% if dp.unit and dp.label != labels.air_quality %}
              <span class="data-point-unit"{% if dp.aqi_color %} style="color: {{ dp.aqi_color }};"{% endif %}>{{ dp.unit }}</span>{% endif %}
              {% if dp.arrow %}
              <span class="wind-arrow-symbol">{{ dp.arrow }}</span>
              {% endif %}
            </div>
          </div>
        </div>
      {% endfor %}
    </div>
  </div>
  {% endif %}

  <!-- Hourly Temperature Graph -->
  {% if plugin_settings.displayGraph and plugin_settings.displayGraph == "true" %}
  <div class="chart-container">
    <canvas id="hourlyTemperatureChart"></canvas>
  </div>
  {% endif %}

  <!-- Forecast Row -->
  {% if plugin_settings.displayForecast and plugin_settings.displayForecast == "true" %}
  <div class="forecast">
    {% for day in forecast[0:(plugin_settings.forecastDays | int)] %}
      <div class="forecast-day">
        <div class="forecast-day-name">{{ day.day }}</div>
        <img class="forecast-icon" src="{{day.icon}}" alt="{{ day.day }} Weather Icon">
        <div class="forecast-temps">
          <span class="high">{{ day.high }}{% if units != "standard" %}°{% endif %}</span> /
          <span class="low">{{ day.low }}{% if units != "standard" %}°{% endif %}</span>
        </div>
        {% if plugin_settings.temperatureBars and plugin_settings.temperatureBars == "true" %}
        <div class="temp-bar-container">
          <div class="temp-bar" data-high="{{ day.high }}" data-low="{{ day.low }}" data-global-max="{{ forecast_temp_max }}" data-global-min="{{ forecast_temp_min }}">
            <div class="temp-bar-fill"></div>
          </div>
        </div>
        {% endif %}
        {% if plugin_settings.moonPhase and plugin_settings.moonPhase == "true" %}
        <div class="separator"></div>
        <div class="moon-phase-container">
        <img class="moon-phase-icon" src="{{day.moon_phase_icon}}" alt="Moon phase icon">
        <span style="flex: 1; white-space: nowrap;">{{day.moon_phase_pct}}%</span>
        </div>
        {% endif %}
        {% if day.air_quality_display %}
        <div class="separator"></div>
        <div class="air-quality-container">
          <div class="air-quality-bar {% if day.air_quality_display.rounded == 'True' %}rounded{% endif %}" 
               style="background-color: {{ day.air_quality_display.color }}; color: white;">
            {{ day.air_quality_display.category }}
          </div>
        </div>
        {% endif %}
      </div>
    {% endfor %}
  </div>
  {% endif %}
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {

    const tempBars = document.querySelectorAll('.temp-bar');
    if (tempBars.length > 0) {
      tempBars.forEach(bar => {
        const high = parseFloat(bar.dataset.high);
        const low = parseFloat(bar.dataset.low);
        const globalMax = parseFloat(bar.dataset.globalMax);
        const globalMin = parseFloat(bar.dataset.globalMin);
        const tempRange = globalMax - globalMin;

        if (tempRange > 0) {
          const topPercent = ((globalMax - high) / tempRange) * 100;
          const bottomPercent = ((globalMax - low) / tempRange) * 100;
          const heightPercent = bottomPercent - topPercent;

          const fill = bar.querySelector('.temp-bar-fill');
          fill.style.top = topPercent + '%';
          fill.style.height = heightPercent + '%';

          const avgTemp = (high + low) / 2;
          let color;
          if (avgTemp >= 30) {
            color = 'linear-gradient(to bottom, #FF6B6B, #FF8E53)';
          } else if (avgTemp >= 20) {
            color = 'linear-gradient(to bottom, #FFB84D, #FFA500)';
          } else if (avgTemp >= 10) {
            color = 'linear-gradient(to bottom, #4ECDC4, #44A08D)';
          } else if (avgTemp >= 0) {
            color = 'linear-gradient(to bottom, #5DADE2, #3498DB)';
          } else {
            color = 'linear-gradient(to bottom, #A7C7E7, #6C8EBF)';
          }
          fill.style.background = color;
        }
      });
    }

    const canvas = document.getElementById('hourlyTemperatureChart');
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();

    // Extract hourly temperature and labels from template variables
    const labels = [{% for hour in hourly_forecast %}"{{ hour.time }}"{% if not loop.last %}, {% endif %}{% endfor %}];
    const timeFull = [{% for hour in hourly_forecast %}"{{ hour.time_full }}"{% if not loop.last %}, {% endif %}{% endfor %}];
    const hours = [{% for hour in hourly_forecast %}{{ hour.hour }}{% if not loop.last %}, {% endif %}{% endfor %}];
    const temperatures = [{% for hour in hourly_forecast %}{{ hour.temperature }}{% if not loop.last %}, {% endif %}{% endfor %}];
    const precipitation = [{% for hour in hourly_forecast %}{{ hour.precipitation }}{% if not loop.last %}, {% endif %}{% endfor %}]; // 0-1 for probability
    const rain = [{% for hour in hourly_forecast %}{{ hour.rain or 0 }}{% if not loop.last %}, {% endif %}{% endfor %}];

    // Map rain to display height using square root (reduces impact of large values)
    const rainHeight = rain.map(r => Math.sqrt(r) * 8); // Increased from 5 to 8 for better visibility
    const maxRainHeight = Math.max(...rainHeight, 1); // At least 1 to avoid divide by zero

    // Sunrise/sunset times
    const sunriseTime = {% if sunrise_time %}"{{ sunrise_time }}"{% else %}null{% endif %};
    const sunsetTime = {% if sunset_time %}"{{ sunset_time }}"{% else %}null{% endif %};
    const sunriseIcon = "{{ sunrise_icon }}";
    const sunsetIcon = "{{ sunset_icon }}";

    // Load icons
    const sunriseImg = new Image();
    const sunsetImg = new Image();
    let iconsLoaded = 0;
    const totalIcons = 2;

    sunriseImg.onload = () => { iconsLoaded++; };
    sunsetImg.onload = () => { iconsLoaded++; };
    sunriseImg.src = sunriseIcon;
    sunsetImg.src = sunsetIcon;
	const units = document.getElementById('units-container').dataset.units;
	const isImperial = units === "imperial";
	const unit = isImperial ? "in" : "mm";
	const threshold = isImperial ? 0.0035 : 0.01;

	// Text color based on theme
	const textColor = {% if dark_mode %}"#FFFFFF"{% else %}"{{ plugin_settings.textColor|default('#000000') if plugin_settings.textColor else '#000000' }}"{% endif %};
	console.log('Dark mode:', {% if dark_mode %}true{% else %}false{% endif %}, 'Text color:', textColor);

    // Helper function to parse HH:MM to minutes
    function parseTime(timeStr) {
      const [h, m] = timeStr.split(':').map(Number);
      return h * 60 + m;
    }

    // Debug: log sunrise/sunset info
    console.log('Sunrise time:', sunriseTime);
    console.log('Sunset time:', sunsetTime);
    console.log('Time data length:', timeFull.length);
    console.log('Dark mode:', {% if dark_mode %}true{% else %}false{% endif %});

    // Find min and max temperatures
    const minTemp = Math.min(...temperatures);
    var maxTemp = Math.max(...temperatures);

    // Create day/night gradient for temperature line
    function createTemperatureGradient(chart) {
      const { ctx, chartArea } = chart;

      // Check if chartArea is available (might not be during initial config)
      if (!chartArea || !chartArea.left || !chartArea.right) {
        return 'rgba(241, 122, 36, 0.9)'; // Fallback to solid orange
      }

      const { left, right } = chartArea;

      if (!sunriseTime || !sunsetTime) {
        return 'rgba(241, 122, 36, 0.9)'; // Fallback to solid orange
      }

      const isDarkMode = {% if dark_mode %}true{% else %}false{% endif %};
      const gradient = ctx.createLinearGradient(left, 0, right, 0);

      // Define colors - optimized for E6 display
      // Use pure colors from E6 standard palette for best contrast
      const dayColor = 'rgb(255, 255, 0)'; // Pure yellow (E6 standard palette) - bright and clear
      const nightColorLight = 'rgb(0, 0, 255)'; // Pure blue (E6 standard palette) - best contrast on e-ink
      const nightColorDark = 'rgb(0, 0, 180)'; // Darker blue for dark mode visibility
      const nightColor = isDarkMode ? nightColorDark : nightColorLight;

      // Parse times
      const sunriseMin = parseTime(sunriseTime);
      const sunsetMin = parseTime(sunsetTime);
      const transitionMinutes = 30;

      // Get time range
      const firstTimeMin = parseTime(timeFull[0]);
      const lastTimeMinRaw = parseTime(timeFull[timeFull.length - 1]);
      let lastTimeMin = lastTimeMinRaw;
      if (lastTimeMinRaw < firstTimeMin) {
        lastTimeMin = lastTimeMinRaw + 24 * 60;
      }
      const timeSpanMin = lastTimeMin - firstTimeMin;

      function timeToPosition(timeMin) {
        if (timeSpanMin === 0) return 0;
        let adjustedTime = timeMin;
        if (timeMin < firstTimeMin) {
          adjustedTime = timeMin + 24 * 60;
        }
        return (adjustedTime - firstTimeMin) / timeSpanMin;
      }

      // Check which events are in range
      const todaySunsetPos = timeToPosition(sunsetMin);
      const todaySunsetInRange = todaySunsetPos >= 0 && todaySunsetPos <= 1;
      const tomorrowSunriseMin = sunriseMin + 24 * 60;
      const tomorrowSunrisePos = timeToPosition(tomorrowSunriseMin);
      const tomorrowSunriseInRange = tomorrowSunrisePos >= 0 && tomorrowSunrisePos <= 1;

      // Determine start/end colors
      const firstTimeMinOriginal = parseTime(timeFull[0]);
      const firstIsDay = firstTimeMinOriginal >= sunriseMin && firstTimeMinOriginal < sunsetMin;
      const lastTimeMinOriginal = parseTime(timeFull[timeFull.length - 1]);
      let lastIsDay = false;
      if (lastTimeMinOriginal < sunriseMin) {
        lastIsDay = false;
      } else if (lastTimeMinOriginal >= sunriseMin && lastTimeMinOriginal < sunsetMin) {
        lastIsDay = true;
      }

      // Build gradient
      gradient.addColorStop(0, firstIsDay ? dayColor : nightColor);

      if (todaySunsetInRange) {
        const sunsetStartPos = todaySunsetPos;
        const sunsetEndPos = Math.min(1, timeToPosition(sunsetMin + transitionMinutes));
        gradient.addColorStop(sunsetStartPos, dayColor);
        if (sunsetEndPos > sunsetStartPos) {
          gradient.addColorStop(sunsetEndPos, nightColor);
        }
      }

      if (tomorrowSunriseInRange) {
        const sunriseStartPos = Math.max(0, timeToPosition(tomorrowSunriseMin - transitionMinutes));
        const sunriseEndPos = tomorrowSunrisePos;
        if (sunriseStartPos < sunriseEndPos) {
          gradient.addColorStop(sunriseStartPos, nightColor);
        }
        gradient.addColorStop(sunriseEndPos, dayColor);
      }

      gradient.addColorStop(1, lastIsDay ? dayColor : nightColor);

      return gradient;
    }

    // Register plugin to create gradient dynamically
    Chart.register({
      id: 'temperatureGradient',
      afterDatasetsDraw(chart) {
        // Draw gradient line after datasets are drawn
        const ctx = chart.ctx;
        const chartArea = chart.chartArea;

        if (!chartArea || !sunriseTime || !sunsetTime) return;

        ctx.save();

        // Create gradient
        const gradient = createTemperatureGradient(chart);

        // Get temperature dataset meta
        const meta = chart.getDatasetMeta(0);

        if (!meta || !meta.data || meta.data.length === 0) {
          ctx.restore();
          return;
        }

        // Use Chart.js's internal path rendering
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 5; // Increased from 3 to 5 for better visibility on E6
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        // Get the path that Chart.js already computed
        const element = meta.data[0];
        if (element && element.$context && element.$context.parsed) {
          ctx.beginPath();

          // Use Catmull-Rom spline for smooth curves matching Chart.js tension: 0.5
          const points = meta.data.map(p => ({ x: p.x, y: p.y }));

          if (points.length > 0) {
            ctx.moveTo(points[0].x, points[0].y);

            for (let i = 0; i < points.length - 1; i++) {
              const p0 = points[Math.max(i - 1, 0)];
              const p1 = points[i];
              const p2 = points[i + 1];
              const p3 = points[Math.min(i + 2, points.length - 1)];

              // Catmull-Rom to Bezier conversion with tension = 0.5
              const tension = 0.5;
              const cp1x = p1.x + (p2.x - p0.x) / 6 * tension;
              const cp1y = p1.y + (p2.y - p0.y) / 6 * tension;
              const cp2x = p2.x - (p3.x - p1.x) / 6 * tension;
              const cp2y = p2.y - (p3.y - p1.y) / 6 * tension;

              ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
            }

            ctx.stroke();
          }
        }

        ctx.restore();
      }
    });

    // Register separate plugin for drawing sunrise/sunset icons
    Chart.register({
      id: 'sunriseSunsetIcons',
      afterDatasetsDraw(chart) {
        // Draw icons after datasets but before axis labels
        const { ctx, chartArea: { top, bottom }, scales: { x } } = chart;

        if (!sunriseTime && !sunsetTime) return;

        ctx.save();

        // Draw sunrise icon
        if (sunriseTime) {
          // Find the closest time point to sunrise
          let sunriseIndex = -1;
          let minDiff = Infinity;
          timeFull.forEach((t, i) => {
            const diff = Math.abs(parseTime(t) - parseTime(sunriseTime));
            if (diff < minDiff) {
              minDiff = diff;
              sunriseIndex = i;
            }
          });

          if (sunriseIndex !== -1) {
            const xPos = x.getPixelForValue(sunriseIndex);
            const iconSize = 14;
            const iconY = bottom + 5; // Position below the axis line

            // Draw icon
            if (sunriseImg.complete && sunriseImg.naturalWidth > 0) {
              ctx.drawImage(sunriseImg, xPos - iconSize/2, iconY, iconSize, iconSize);
            }
          }
        }

        // Draw sunset icon
        if (sunsetTime) {
          // Find the closest time point to sunset
          let sunsetIndex = -1;
          let minDiff = Infinity;
          timeFull.forEach((t, i) => {
            const diff = Math.abs(parseTime(t) - parseTime(sunsetTime));
            if (diff < minDiff) {
              minDiff = diff;
              sunsetIndex = i;
            }
          });

          if (sunsetIndex !== -1) {
            const xPos = x.getPixelForValue(sunsetIndex);
            const iconSize = 14;
            const iconY = bottom + 5; // Position below the axis line

            // Draw icon
            if (sunsetImg.complete && sunsetImg.naturalWidth > 0) {
              ctx.drawImage(sunsetImg, xPos - iconSize/2, iconY, iconSize, iconSize);
            }
          }
        }

        ctx.restore();
      }
    });

    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          type: 'line',
          label: 'Hourly Temperature',
          data: temperatures,
          borderColor: 'rgba(0, 0, 0, 0)', // Transparent - we'll draw our own gradient line
          borderWidth: 0,
          pointRadius: 0,
          fill: false,
          tension: 0.5
        },
        {
          type: 'bar',
          label: 'Precipitation Amount',
          data: rainHeight, // Use mapped rain height instead of probability
          backgroundColor: function(context) {
            const index = context.dataIndex;
            const prob = precipitation[index];

            // Use light blue tones based on probability (distinct from dark blue temperature line)
            // Temperature line at night: rgba(30, 45, 100) - dark blue-purple (~20% brightness)
            // Precipitation bars: light cyan-blue (~70% brightness) - high contrast
            if (prob >= 0.7) return 'rgba(100, 181, 246, 0.8)';      // 70%+ medium cyan-blue
            else if (prob >= 0.5) return 'rgba(129, 199, 247, 0.7)'; // 50-70% light cyan-blue
            else if (prob >= 0.3) return 'rgba(159, 214, 250, 0.6)'; // 30-50% very light cyan-blue
            else if (prob >= 0.1) return 'rgba(187, 228, 252, 0.45)'; // 10-30% extremely light
            else return 'rgba(225, 245, 254, 0.3)';                  // <10% almost white with blue tint
          },
          borderColor: 'rgba(26, 111, 176, 1)', // Keep blue border for water association
          borderWidth: {
            top: 2,
            right: 0,
            bottom: 0,
            left: 0
          },
          yAxisID: 'y1',
          barPercentage: 1.0,
          categoryPercentage: 1.0,
        }
      ]
      },
      options: {
        animation: {
          duration: 0, // general animation time
        },
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            ticks: {
              autoSkip: false,
              padding: 0,
              maxRotation: 0,
              minRotation: 0,
              color: textColor,
              font: {
                family: 'Jost'
              },
              // Only show even hours
              callback: function(value, index, values) {
                const hour = hours[index];

                // Only show even hours
                if (hour % 2 !== 0) return '';

                // Show this even hour
                return labels[index];
              }
            },
            grid: {
              tickLength: 0,
              display: false // Hide x-axis grid
            },
            offset: false,  // Remove padding at start and end
            gridLines: {
                drawBorder: false,
            }
          },
          y: {
            ticks: {
              padding: 0,
              color: textColor,
              font: {
                family: 'Jost'
              },
              autoSkip: false,
              callback: function(value, index, values) {
                if (index === values.length-1) return maxTemp + "°";
                else if (index === 0) return minTemp + "°";
                else return '';
              }
            },
            grid: { display: false },
            min: minTemp,
            max: maxTemp,
          },
          y1: {
            position: 'right',
            grid: { display: false },
            ticks: {
              padding: 0,
              color: textColor,
              font: {
                family: 'Jost'
              },
              autoSkip: false,
              callback: function(value, index, values) {
                if (index === values.length - 1) {
                  // Calculate actual rain amount from mapped height (using factor of 8)
                  const actualRain = Math.pow(maxRainHeight / 8, 2);
                  return actualRain.toFixed(1) + unit;
                }
                else if (index === 0) return "0" + unit;
                else return '';
              }
            },
            min: 0,
            max: maxRainHeight,
          }
        },
        plugins: {
          legend: { display: false }
        },
        elements: {
          line: {
            borderJoinStyle: 'round' // Smoother line connection
          }
        }
      }
    });

  });
</script>
{% endblock %}
