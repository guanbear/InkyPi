{% extends "plugin.html" %}

{% block content %}
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">

<div id="units-container" data-units="{{ units }}"></div>


<div class="weather-dashboard {% if dark_mode %}dark-mode{% endif %} {% if display_style == 'nothing' %}nothing-style{% elif display_style == 'qweather' %}qweather-style{% endif %}">
  {% if plugin_settings.displayRefreshTime == "true" %}
  <div class="last-refresh">{{ labels.last_refresh }}: {{ last_refresh_time }}</div>
  {% endif %}
  <!-- Current Date -->
  <div class="header {% if weather_alerts and weather_alerts|length > 0 %}has-alerts{% endif %}">
    <div class="title">{{ title }}</div>
    <div class="header-bottom-row">
      {% if weather_alerts and weather_alerts|length > 0 %}
      <div class="weather-alerts-inline">
        {% for alert in weather_alerts %}
          <div class="weather-alert-inline" style="background-color: {{ alert.bg_color }}; color: {{ alert.text_color }};">
            <span class="alert-icon-inline">⚠</span>
            <span class="alert-headline-inline">{{ alert.headline }}</span>
          </div>
        {% endfor %}
      </div>
      {% endif %}
      <div class="current-date">{{ current_date }}</div>
    </div>
  </div>

  <div class="today-container">
    <!-- Current Weather Row -->
    <div class="current-temperature">
      <!-- Icon + Temperature -->
        <img class="current-icon" src="{{current_day_icon}}" alt="Current Weather Icon">
        <div class="current-weather">
          <div class="current-temp">{{ current_temperature }}<span class="temperature-unit">{{temperature_unit}}</span></div>
          <div class="feels-like">{{ labels.feels_like }} {{ feels_like }}{% if units != "standard" %}°{% endif %}</div>
          <div class="min-max">{{ forecast[0].high }}{% if units != "standard" %}°{% endif %} / {{ forecast[0].low }}{% if units != "standard" %}°{% endif %}</div>
        </div>
    </div>

    <!-- Data Points Grid (Sunset, Wind, UV, etc.) -->
    {% if plugin_settings.displayMetrics and  plugin_settings.displayMetrics == "true" %}
    <div class="data-points">
      {% for dp in data_points %}
        <div class="data-point column-container">
          <div class="data-point-img-container">
            <img class="data-point-icon{% if dp.icon and 'air-quality.png' in dp.icon %} aqi-icon{% endif %}" 
                 src="{{dp.icon}}" alt="{{ dp.label }}">
          </div>
          <div class="data-point-data">
            <div class="data-point-label">{{ dp.label }}</div>
            <div class="data-point-measurement"{% if dp.aqi_color %} style="color: {{ dp.aqi_color }};"{% endif %}>{{ dp.measurement }}{% if dp.unit %}
              <span class="data-point-unit"{% if dp.aqi_color %} style="color: {{ dp.aqi_color }};"{% endif %}>{{ dp.unit }}</span>{% endif %}
            </div>
          </div>
        </div>
      {% endfor %}
    </div>
  </div>
  {% endif %}

  <!-- Hourly Temperature Graph -->
  {% if plugin_settings.displayGraph and plugin_settings.displayGraph == "true" %}
  <div class="chart-container">
    <canvas id="hourlyTemperatureChart"></canvas>
  </div>
  {% endif %}

  <!-- Forecast Row -->
  {% if plugin_settings.displayForecast and plugin_settings.displayForecast == "true" %}
  <div class="forecast">
    {% for day in forecast[0:(plugin_settings.forecastDays | int)] %}
      <div class="forecast-day">
        <div class="forecast-day-name">{{ day.day }}</div>
        <img class="forecast-icon" src="{{day.icon}}" alt="{{ day.day }} Weather Icon">
        <div class="forecast-temps">
          <span class="high">{{ day.high }}{% if units != "standard" %}°{% endif %}</span> /
          <span class="low">{{ day.low }}{% if units != "standard" %}°{% endif %}</span>
        </div>
        {% if plugin_settings.temperatureBars and plugin_settings.temperatureBars == "true" %}
        <div class="temp-bar-container">
          <div class="temp-bar" data-high="{{ day.high }}" data-low="{{ day.low }}" data-global-max="{{ forecast_temp_max }}" data-global-min="{{ forecast_temp_min }}">
            <div class="temp-bar-fill"></div>
          </div>
        </div>
        {% endif %}
        {% if plugin_settings.moonPhase and plugin_settings.moonPhase == "true" %}
        <div class="separator"></div>
        <div class="moon-phase-container">
        <img class="moon-phase-icon" src="{{day.moon_phase_icon}}" alt="Moon phase icon">
        <span style="flex: 1;">{{day.moon_phase_pct}} %</span>
        </div>
        {% endif %}
      </div>
    {% endfor %}
  </div>
  {% endif %}
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {

    const tempBars = document.querySelectorAll('.temp-bar');
    if (tempBars.length > 0) {
      tempBars.forEach(bar => {
        const high = parseFloat(bar.dataset.high);
        const low = parseFloat(bar.dataset.low);
        const globalMax = parseFloat(bar.dataset.globalMax);
        const globalMin = parseFloat(bar.dataset.globalMin);
        const tempRange = globalMax - globalMin;

        if (tempRange > 0) {
          const topPercent = ((globalMax - high) / tempRange) * 100;
          const bottomPercent = ((globalMax - low) / tempRange) * 100;
          const heightPercent = bottomPercent - topPercent;

          const fill = bar.querySelector('.temp-bar-fill');
          fill.style.top = topPercent + '%';
          fill.style.height = heightPercent + '%';

          const avgTemp = (high + low) / 2;
          let color;
          if (avgTemp >= 30) {
            color = 'linear-gradient(to bottom, #FF6B6B, #FF8E53)';
          } else if (avgTemp >= 20) {
            color = 'linear-gradient(to bottom, #FFB84D, #FFA500)';
          } else if (avgTemp >= 10) {
            color = 'linear-gradient(to bottom, #4ECDC4, #44A08D)';
          } else if (avgTemp >= 0) {
            color = 'linear-gradient(to bottom, #5DADE2, #3498DB)';
          } else {
            color = 'linear-gradient(to bottom, #A7C7E7, #6C8EBF)';
          }
          fill.style.background = color;
        }
      });
    }

    const canvas = document.getElementById('hourlyTemperatureChart');
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();

    // Extract hourly temperature and labels from template variables
    const labels = [{% for hour in hourly_forecast %}"{{ hour.time }}"{% if not loop.last %}, {% endif %}{% endfor %}];
    const temperatures = [{% for hour in hourly_forecast %}{{ hour.temperature }}{% if not loop.last %}, {% endif %}{% endfor %}];
    const precipitation = [{% for hour in hourly_forecast %}{{ hour.precipitation * 100}}{% if not loop.last %}, {% endif %}{% endfor %}]; // Convert to percentage
    const rain = [{% for hour in hourly_forecast %}{{ hour.rain or 0 }}{% if not loop.last %}, {% endif %}{% endfor %}];
	const units = document.getElementById('units-container').dataset.units;
	const isImperial = units === "imperial";
	const unit = isImperial ? "in" : "mm";
	const threshold = isImperial ? 0.0035 : 0.09;

	// Text color based on theme
	const textColor = {% if dark_mode %}"#FFFFFF"{% else %}"{{ plugin_settings.textColor|default('#000000') }}"{% endif %};

    // Find min and max temperatures
    const minTemp = Math.min(...temperatures);
    var maxTemp = Math.max(...temperatures);
	
    Chart.register({
      id: 'annotationRain',
      afterDatasetsDraw(chart, args, pluginOptions) {
        const { ctx } = chart;
        const rainData = pluginOptions.precipitationData || [];
        const meta = chart.getDatasetMeta(1);

        ctx.save();
        ctx.textAlign = 'center';

        meta.data.forEach((bar, i) => {
          const rainAmount = rainData[i];
          if (rainAmount && rainAmount > threshold) {
            const x = bar.x;
            const y = bar.y;
			const base = bar.base;
			const height = base - y;

			let textY, unitY;

			if (height < 25) {
			  textY = y - 10;
			  unitY = y - 3;
			} else {
			  textY = y + 13;
			  unitY = y + 20;
			}
            ctx.fillStyle = textColor;
            ctx.fillText(rainAmount.toFixed(2), x, textY);
            ctx.fillText(unit, x, unitY);
          }
        });

        ctx.restore();
      }
    });

    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          type: 'line',
          label: 'Hourly Temperature',
          data: temperatures,
          borderColor: 'rgba(241, 122, 36, 0.9)', // Line color
          borderWidth: 2,
          pointRadius: 0, // Hide points
          fill: true, // Enable filling the area under the line
          tension: 0.5
        },
        {
          type: 'bar',
          label: 'Precipitation Probability',
          data: precipitation,
          borderColor: 'rgba(26, 111, 176, 1)', // Semi-transparent blue
          borderWidth: {
            top: 2,
            right: 0,
            bottom: 0,
            left: 0
          },
          yAxisID: 'y1',
          barPercentage: 1.0, // Ensures full width
          categoryPercentage: 1.0,  // Ensures full width
          fill: true, // Enable filling the area under the line
        }
      ]
      },
      options: {
        animation: {
          duration: 0, // general animation time
        },
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            ticks: {
              autoSkip: true,
              padding: 0,
              maxRotation: 0, // Prevent label rotation
              minRotation: 0, // Prevent label rotation
              color: textColor,
              font: {
                family: 'Jost'
              }
            },
            grid: {
              tickLength: 0,
              display: false // Hide x-axis grid
            },
            offset: true,
            gridLines: {
                drawBorder: false,
            }
          },
          y: {
            ticks: {
              padding: 0,
              color: textColor,
              font: {
                family: 'Jost'
              },
              autoSkip: false,
              callback: function(value, index, values) {
                if (index === values.length-1) return maxTemp + "°";
                else if (index === 0) return minTemp + "°";
                else return '';
              }
            },
            grid: { display: false },
            min: minTemp,
            max: maxTemp,
          },
          y1: {
            position: 'right',
            grid: { display: false },
            ticks: {
              padding: 0,
              color: textColor,
              font: {
                family: 'Jost'
              },
              autoSkip: false,
              callback: function(value, index, values) {
                if (index === values.length - 1) return "100%";
                else if (index === 0) return "0%";
                else return '';
              }
            },
            min: 0,
            max: 100,
          }
        },
        plugins: {
          legend: { display: false },
		  {% if plugin_settings.displayRain == "true" %}
			annotationRain: { precipitationData: rain }
	      {% endif %}
        },
        elements: {
          line: {
            borderJoinStyle: 'round' // Smoother line connection
          }
        }
      }
    });

    chart.update();

    // Now, after the chart is created, we can access the scales
    const gradientStart = chart.scales['y'].getPixelForValue(maxTemp); // Max temperature
    const gradientEnd = chart.scales['y'].getPixelForValue(minTemp);   // Min temperature

    // Create gradient based on y-axis values
    const tempGradient = ctx.createLinearGradient(0, gradientStart, 0, gradientEnd+10);
    tempGradient.addColorStop(0, 'rgba(252,204,5, 0.95)'); // Top of the gradient (max temperature)
    tempGradient.addColorStop(1, 'rgba(252,204,5, 0.01)'); // Bottom of the gradient (min temperature)

    // Update the chart to apply the gradient
    chart.data.datasets[0].backgroundColor = tempGradient;

    // Create gradient based on y-axis values
    const precipitationGradient = ctx.createLinearGradient(0, gradientStart, 0, gradientEnd);
    precipitationGradient.addColorStop(0, 'rgba(26, 111, 176, 0.8)'); // Top of the gradient (max temperature)
    precipitationGradient.addColorStop(1, 'rgba(194, 223, 246, 0)'); // Bottom of the gradient (min temperature)

    chart.data.datasets[1].backgroundColor = precipitationGradient;

    chart.update();
  });
</script>
{% endblock %}
